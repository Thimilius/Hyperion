#ifndef HYP_STANDARD_LIGHTING_INCLUDE
#define HYP_STANDARD_LIGHTING_INCLUDE

struct Light {
	float intensity;
	vec4 color;
	
	vec3 direction;
	
	vec3 position;
	float range;
	
	float spot_inner_radius;
	float spot_outer_radius;
};

const int LIGHTING_MAX_POINT_LIGHT_COUNT = 3;
const int LIGHTING_SPECULAR_EXPONENT = 15;
struct Lighting {
	vec3 ambient_color;

	Light main_light;

	Light point_lights[LIGHTING_MAX_POINT_LIGHT_COUNT];
	int point_light_count;
};

uniform Lighting u_lighting;

float calculate_light_attenuation(float distance, float light_range) {
	float attenuation_linear = 4.5 / light_range;
	float attenuation_quadratic = 75.0 / (light_range * light_range);
	return 1.0 / (1.0 + attenuation_linear * distance + attenuation_quadratic * distance * distance);
}

vec3 calculate_phong_directional_light(vec3 position, vec3 normal, Light light) {
	// Diffuse
	float diffuse_intensity = light.intensity;
	vec3 to_light_direction = normalize(-light.direction);	
	diffuse_intensity = diffuse_intensity * max(dot(normal, to_light_direction), 0.0);
	vec3 diffuse_lighting = diffuse_intensity * light.color.rgb;
	
	// Specular
	float specular_intensity = light.intensity;
	vec3 to_camera_direction = normalize(u_camera.position - position);
	vec3 reflection_direction = reflect(-to_light_direction, normal);
	specular_intensity = specular_intensity * pow(max(dot(to_camera_direction, reflection_direction), 0.0), LIGHTING_SPECULAR_EXPONENT);
	vec3 specular_lighting = specular_intensity * light.color.rgb;
	
	// Final lighting
	vec3 lighting_color = diffuse_lighting + specular_lighting;

	return lighting_color;
}

vec3 calculate_phong_point_light(vec3 position, vec3 normal, Light light) {
	// Diffuse
	float diffuse_intensity = light.intensity;
	vec3 to_light_direction = normalize(light.position - position);
	diffuse_intensity = diffuse_intensity * max(dot(normal, to_light_direction), 0.0);
	vec3 diffuse_lighting = diffuse_intensity * light.color.rgb;
	
	// Specular
	float specular_intensity = light.intensity;
	vec3 to_camera_direction = normalize(u_camera.position - position);
	vec3 reflection_direction = reflect(-to_light_direction, normal);
	specular_intensity = specular_intensity * pow(max(dot(to_camera_direction, reflection_direction), 0.0), LIGHTING_SPECULAR_EXPONENT);
	vec3 specular_lighting = specular_intensity * light.color.rgb;
	
	// Attenuation
	float attenuation = calculate_light_attenuation(distance(light.position, position), light.range);
	
	// Final lighting
	vec3 lighting_color = attenuation * diffuse_lighting + attenuation * specular_lighting;

	return lighting_color;
}

vec3 calculate_phong_lighting(vec3 position, vec3 normal) {
	vec3 main_lighting = calculate_phong_directional_light(position, normal, u_lighting.main_light);

	vec3 point_lighting;
	for (int i = 0; i < u_lighting.point_light_count; i++) {
		point_lighting += calculate_phong_point_light(position, normal, u_lighting.point_lights[i]);
	}

	return main_lighting + point_lighting + u_lighting.ambient_color;
}

#endif // HYP_PHONG_LIGHTING_INCLUDE